Fórmula de Gauss: n
                  Σ i  =  (n(n + 1))/2
                  0

TAD: lista

insere e remove em qualquer posição

class Lista {
    int[] array;
    int n;

    Lista(){ this (6); }
    Lista(int tamanho){
        array = new int[tamanho];
        n = 0;
    }

    void inserirInicio(int x) throws Exception {
        if (n >= array.length)
            throw new Exception("Erro!");
        
        //levar elementos para o fim do array
        for(int i = n; i > 0; i++){
            array[i] = array[i-1];
        }

        array[0] = x;
        n++;
    }

    void inserirFim(int x) throws Exception {
        if (n >= array.length)
            throw new Exception("Erro!");
        
        array[n] = x;     //array[n++] = x; tbm ta certo
        n++;
    }

    void inserir(int x, int pos) throws Exception {
        if (n >= array.length || pos < 0 || pos > n)
            throw new Exception("Erro!");

        //levar elementos para o fim do array
        for(int i = n; i > pos; i--){
            array[i] = array[i-1];
        }
                                                                               <----LISTA
        array[pos] = x;
        n++;
    }

    int removerInicio() throws Exception {
        if(n == 0)
            throw new Exception("Erro!");
        
        int resp = array[0];
        n--;

        for(int i = 0; i < n; i++){
            array[i] = array[i + 1];
        }

        return resp;
    }

    int removerFim() throw Exception {
        if(n == 0)
            throw new Exception(Erro!);

        return array[--n];
    }

    int remover(int pos) throw Exception {
        if(n == 0 || pos < 0 || pos >= n)
            throw new Exception(Erro!);

        int resp = array[pos];
        n--;

        for(int i = pos; i < n; i++){
            array[i] = array[i+1];
        }

        return resp;
    }

    void mostrar() {
        System.out.print("[ ");
        for(int i = 0; i < n ; i++){
            System.out.print(array[i] + " ");
        } 
        System.out.println(" ]");
    }
}




TAD: pilha

First In, Last out(FILO) 
ou 
Last In, First Out(LIFO)

class Pilha {

    primeira solução: IF e RF   <----- melhor opção

    void inserirFim(int x) throws Exception {
        if (n >= array.length)
            throw new Exception("Erro!");
        
        array[n] = x;     //array[n++] = x; tbm ta certo
        n++;
    }

    int removerFim() throw Exception {
        if(n == 0)
            throw new Exception(Erro!);

        return array[--n];
    }

    ou, segunda solução: II e RI  <---- método menos eficiente
                                                                               <----PILHA
    void inserirInicio(int x) throws Exception {
        if (n >= array.length)
            throw new Exception("Erro!");
        
        //levar elementos para o fim do array
        for(int i = n; i > 0; i++){
            array[i] = array[i-1];
        }

        array[0] = x;
        n++;
    }

    int removerInicio() throws Exception {
        if(n == 0)
            throw new Exception("Erro!");
        
        int resp = array[0];
        n--;

        for(int i = 0; i < n; i++){
            array[i] = array[i + 1];
        }

        return resp;
    }

}

TAD: fila

First In, First Out(FIFO)
ou
Last In, Last Out(LILO)

class Fila{

    primeira solução: IF e RI <----remoção não é eficiente

    void inserirFim(int x) throws Exception {
        if (n >= array.length)
            throw new Exception("Erro!");
        
        array[n] = x;     //array[n++] = x; tbm ta certo
        n++;
    }

    int removerInicio() throws Exception {
        if(n == 0)
            throw new Exception("Erro!");
        
        int resp = array[0];
        n--;

        for(int i = 0; i < n; i++){
            array[i] = array[i + 1];
        }

        return resp;
    }
                                                                               <----FILA
    ou, segunda solução: II e RF <---- inserção não é eficiente

    void inserirInicio(int x) throws Exception {
        if (n >= array.length)
            throw new Exception("Erro!");
        
        //levar elementos para o fim do array
        for(int i = n; i > 0; i++){
            array[i] = array[i-1];
        }

        array[0] = x;
        n++;
    }

    int removerFim() throw Exception {
        if(n == 0)
            throw new Exception(Erro!);

        return array[--n];
    }
}

TAD fila circular

class FilaCircular{
    avanço ciruclar:
    for(int i = 0; i < n+1; i = (i+1) % n)

    retroceder circular: 
    for(int i = 0; i < n+1; i = (i-1+n) % n)
}

perguntar se o numero da fila circular sobrescreve o outro, se sim, ele vai pro lixo?

https://github.com/matheusbarrosp/Oficina_AEDs2_2025-2/blob/main/Oficina2/estruturas_lineares/codigo_base/exerc1.c

ordenação Bolha

public void sort() {
    for (int i = (n-1); 1 > 0; i--) {
        for (int j = 0; j < i; j++) {
            if (array[j] > array[j + 1]) {
                swap(j, j++);
            }
        }
    }
}
                                                                               <----BOLHA
ordenação Inserção

for(int i = 1; i < n; i++) {
    int temp = array[i];
    int j = i - 1;
    while (j >= 0) && (array[j] > temp) {
        array[j + 1] = array[j]; //deslocamento
        j--;
    }
    array[j + 1] = temp;
}

melhor caso: array ordenado
pior caso: array decrescente
                                                                               <----INSERÇÃO


public class MergeSort {

    // Método principal que inicia a ordenação
    public void sort(int[] array) {
        // Chama o método recursivo com o array completo
        mergeSort(array, 0, array.length - 1);
    }

    // Método recursivo que divide o array
    private void mergeSort(int[] array, int esquerda, int direita) {
        // Condição de parada da recursão: quando o sub-array tem 1 elemento
        if (esquerda < direita) {
            // Encontra o ponto médio do array
            int meio = (esquerda + direita) / 2;

            // Ordena a primeira metade (da esquerda até o meio)
            mergeSort(array, esquerda, meio);
            // Ordena a segunda metade (do meio+1 até a direita)
            mergeSort(array, meio + 1, direita);

            // Mescla as duas metades já ordenadas
            merge(array, esquerda, meio, direita);
        }
    }

    // Método que mescla (intercala) dois sub-arrays ordenados
    private void merge(int[] array, int esquerda, int meio, int direita) {
        // Calcula o tamanho dos sub-arrays temporários
        int tamanhoEsquerda = meio - esquerda + 1;
        int tamanhoDireita = direita - meio;

        // Cria arrays temporários para as metades
        int[] arrayEsquerda = new int[tamanhoEsquerda];
        int[] arrayDireita = new int[tamanhoDireita];

        // Copia os dados para os arrays temporários
        for (int i = 0; i < tamanhoEsquerda; ++i) {
            arrayEsquerda[i] = array[esquerda + i];
        }
        for (int j = 0; j < tamanhoDireita; ++j) {
            arrayDireita[j] = array[meio + 1 + j];
        }
                                                                               <----MERGESORT
        // --- Início da mesclagem ---
        int i = 0; // Índice inicial do primeiro sub-array
        int j = 0; // Índice inicial do segundo sub-array
        int k = esquerda; // Índice inicial do array principal mesclado

        // Compara e intercala os elementos dos arrays temporários no array original
        while (i < tamanhoEsquerda && j < tamanhoDireita) {
            if (arrayEsquerda[i] <= arrayDireita[j]) {
                array[k] = arrayEsquerda[i];
                i++;
            } else {
                array[k] = arrayDireita[j];
                j++;
            }
            k++;
        }

        // Copia os elementos restantes do arrayEsquerda, se houver
        while (i < tamanhoEsquerda) {
            array[k] = arrayEsquerda[i];
            i++;
            k++;
        }

        // Copia os elementos restantes do arrayDireita, se houver
        while (j < tamanhoDireita) {
            array[k] = arrayDireita[j];
            j++;
            k++;
        }
    }

    // Método para testar a implementação
    public static void main(String[] args) {
        int[] meuArray = {54, 26, 93, 17, 77, 31, 44, 55, 20};

        System.out.println("Array original:");
        for (int valor : meuArray) {
            System.out.print(valor + " ");
        }

        MergeSort sorter = new MergeSort();
        sorter.sort(meuArray);

        System.out.println("\n\nArray ordenado:");
        for (int valor : meuArray) {
            System.out.print(valor + " ");
        }
        System.out.println();
    }
}
                                                                               <----QUICKSORT
void quicksort(int esq, int dir) {
    int i = esq, j = dir, pivo = array[(esq + dir)/2];
    while(i <= j) {
        while(array[i] < pivo)
            i++;
        while(array[j] > pivo)
            j--;
        if(i <= j)
        {   swap(i,j) i++; j--; }
    }
    if(esq < j)
        quicksort(esq, j);
    if(i < dir)
        quicksort(i, dir);
}
                                                                               <----HEAPSORT
public class Hepasort{
    void heapsort(){
        //construcao do heapsort
        for(int tam = 2; tam <= n; tam++){
            construir(tam);
        }

        //ordenacao propriamente dita 
        int tam = n;
        while(tam > 1){
            swap(1, tam--);
            reconstruir(tam);
        }
    }

    void construir(int tam){
        for(int i = tam; i > 1 && array[i] > array[i/2]; i /= 2){
            swap(i, i/2);
        }
    }

    void reconstruir(int tam){
        int i = 1;
        while(hasFilho(i, tam) == true){
            int filho = getMaiorFilho(i, tam);
            if(array[i] < array[filho]){
                swap(i, filho);
                i = filho;
            } else {
                i = tam;
            }
        }
    }
}
                                                                               <----SHELLSORT
public class Shellsort{
    void shellsort(){
        int h = 1;
        do { h = (h * 3) + 1;} while (h < n);
        do {
            h /= 3;
            for(int cor = 0; cor < h; cor++){
                insercaoPorCor(cor, h);
            }
        } while (h != 1);
    }

    void insercaoPorCor(int cor, int h){
        for(int i = (h + cor); i < n; i += h){
            int temp = array[i];
            int j = i - h;
            while((j >= 0) && (array[j] > temp)){
                array[j + h] = array[j];
                j -= h;
            }
            array[j + h] = temp;
        }
    }

    void insercao(){
        for(int i = 1; i < n; i += 1){
            int tmp = array[i];
            int j = i - 1;
            while((j >= 0) && (array[j] > tmp)){           //nao usada, apenas para comparar com a insercaoPorCor
                array[j + 1] = array[j];
                j -= 1;
            }
            array[j + 1] = tmp;
        }
    }
}